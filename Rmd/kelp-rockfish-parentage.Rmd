---
title: "Doing Parentage on the Kelp Rockfish"
output: 
  html_notebook:
    toc: true
---


This is a first stab at winnowing down our samples to just a few species of rockfish,
and figuring out which they are.  I am going to go for this with structure.


To start off with, let's load data and libs:
```{r load-stuff}
library(tidyverse)
library(CKMRsim)
library(stringr)

meta <- readRDS("../data/processed/meta-data-tibble.rds")
genos <- readRDS("../extdata/processed/genos-aggregated-and-no-hi-missers.rds")
species <- readRDS("../data/processed/juvie-gsi-sim-assignments.rds") 
```


## Selecting our fish and designating allele nomenclature

We gotta pick out the _S. atrovirens_.  For adults that is pretty much already done, just by who they
are, but we must use the GSI assignments for the juveniles.
```{r define-kelps}
kelp_ad <- meta %>% 
  filter(SPECIES == "atrovirens",
         REPORTED_LIFE_STAGE == "ADULT") %>%
  select(NMFS_DNA_ID) %>% unlist() %>% unname()

kelp_juv <- species %>%
  filter(species == "atrovirens",
         score > 99.9) %>%
  select(NMFS_DNA_ID) %>% unlist() %>% unname

```

With those we can just filter down the genos to the ones that we want, and then we
can get it into the format required for CKMR.
```{r kelp-genos}
kelp_genos <- genos %>%
  filter(NMFS_DNA_ID %in% c(kelp_ad, kelp_juv))

# we will use this some more
kg2 <- kelp_genos %>% 
  select(NMFS_DNA_ID, locus, allele) %>%
  mutate(Chrom = "GTseq") %>% 
  mutate(Pos = as.integer(factor(locus, levels = unique(locus)))) %>%
  rename(Locus = locus,
         Allele = allele) %>%
  select(NMFS_DNA_ID, Chrom, Locus, Pos, Allele) %>%
  ungroup()

# get the allele freqs
kg_ckmr_markers <- kg2 %>%
  filter(!is.na(Allele)) %>% # it is vital to filter out the NAs at this stage
  group_by(Chrom, Locus, Pos, Allele) %>%
  summarise(counts = n()) %>%
  group_by(Locus, Pos) %>%
  mutate(Freq = counts / sum(counts)) %>%
  select(-counts) %>%
  mutate(AlleIdx = 1,
         LocIdx = 1) %>%
  reindex_markers(.)
```
Great! We have a total `r nrow(kg_ckmr_markers)` alleles in this data set.


## Doing CKMR simulations to assess power

Really simply let's just do this to see what our power for parentage ought to look like.
```{r CKMR-create}
CK <- create_ckmr(kg_ckmr_markers, kappa_matrix = kappas[c("PO", "FS", "U"), ])

# see what it tells us when we print it:
CK
```

Then do the simulations to see what the false positive rates are for finding parents when the truth
is U or FS:
```{r CKMR-sim-and-sample}
Qs <- simulate_Qij(C = CK, froms = c("PO", "FS", "U"), tos = c("PO", "FS", "U"), reps = 10^4)

# then do the importance sampling to get the FPRs
mc_sample_simple(Qs, nu = "PO", de = c("U", "FS"), tr = c("U", "FS"), method = "both")
```
We can come back to that later to see about finding Full Sibs.

## Making genotype matrices
```{r}
kelp_haps <- kelp_genos %>%
  filter(!is.na(allele)) %>%  # once again, it is critical to remove these at this point
  select(NMFS_DNA_ID, locus, gene_copy, allele) %>%
  rename(Locus = locus, Allele = allele)

kelp_idx_frame <- kg_ckmr_markers %>%
  select(Locus, Allele, LocIdx, AlleIdx) %>%
  group_by(Locus) %>%
  mutate(NumA = n()) %>%  # get the number of alleles at each locus
  ungroup() %>%
  left_join(kelp_haps, .)  %>%  # join the alle_idx's onto the actual genotype data
  select(NMFS_DNA_ID, Locus, gene_copy, LocIdx, NumA, AlleIdx) %>%
  spread(key = gene_copy, value = AlleIdx) %>%
  mutate(GenoIdx = index_ab(a = `1`, b = `2`, A = NumA))

# make a matrix of genotype integers 
wide_kelp <- kelp_idx_frame %>%
  select(NMFS_DNA_ID, LocIdx, GenoIdx) %>%
  spread(data = ., key = LocIdx, value = GenoIdx)
```

Don't forget to set NA's to 0, and then decrease each value by 1:
```{r make-mat}
rocky_mat <- as.matrix(wide_kelp[, -1])
rownames(rocky_mat) <- wide_kelp$NMFS_DNA_ID
rocky_mat[is.na(rocky_mat)] <- 0
rocky_mat <- rocky_mat - 1
storage.mode(rocky_mat) <-  "integer"
```

## Looking for duplicated samples

We can quickly look through rocky_mat for pairs of indivs with lots of matching genotypes.
```{r check-for-dupes}
matchers <- pairwise_geno_id(S = rocky_mat, max_miss = 12) %>%
  arrange(num_mismatch)
matchers
```
We need to deal with these somehow.  I am going to say that anyone with 3 or fewer mismatches is certainly 
the same individual, and we are going to take just one from amongst those pairs/groups.  We use a hasty method:
we toss out all the individuals that appear in both ind1 and ind2, and then all the remaining ind2's.  This 
might throw out one more than we need to, but it is what we do for now.
```{r toss-matchers}
def_same <- matchers %>%
  filter(num_mismatch <= 3)

toss_these <- c(intersect(def_same$ind1, def_same$ind2), def_same$ind2) %>%
  unique()

rocky_mat_tossed <- rocky_mat[-toss_these,]
```

Now we have to break that into two matrices: one for the adults and one for the kids.
This should not be too hard.  We have to deal with the fact that not all of the adults in the meta data
had few enough missing genotypes to be included.
```{r break-stage}
kelp_ad_kept <- kelp_ad[kelp_ad %in% rownames(rocky_mat_tossed)]
kelp_juv_kept <- kelp_juv[kelp_juv %in% rownames(rocky_mat_tossed)]

adult_mat <- rocky_mat_tossed[kelp_ad_kept, ]
juvie_mat <- rocky_mat_tossed[kelp_juv_kept, ]
```

## Doing the comparisons

We need to flatten the CKMR object appropriately
```{r flatten}
# flatten those out
po_flat <- flatten_ckmr(CK, "PO")
unrel_flat <- flatten_ckmr(CK, "U")

# then compute the log-likelihoods for the parent offspring relationship
po_logl_flat <- po_flat
po_logl_flat$probs <- log(po_flat$probs / unrel_flat$probs)

```


Now we are ready to do these!
```{r do-comps}
idx <- 1:nrow(juvie_mat)
names(idx) <- idx
comps <- lapply(idx, function(i) {
    tmp <- comp_ind_pairwise(S = adult_mat, T = juvie_mat, t = i, values = po_logl_flat$probs, nGenos = po_logl_flat$nGenos, Starts = po_logl_flat$base0_locus_starts)
    #tmp[rev(top_index(tmp$value, 5)), ]  # just take the top 5 from each
    }) %>%
  dplyr::bind_rows(.id = "offspring") %>%
  dplyr::tbl_df() 

# have a look at that
result <- arrange(comps, desc(value)) %>%
  mutate(number = 1:nrow(.)) %>%
  mutate(id1 = rownames(juvie_mat)[as.integer(offspring)],
         id2 = rownames(adult_mat)[ind])

result %>% filter(number <= 1000)

```

Try plotting all those pairs, and compare them to the simulated values
```{r plot-all-pairs-density}
simlogls <- extract_logls(Q = Qs, numer = c(PO = 1), denom = c(U = 1))
ggplot(result, aes(x = value)) +
  geom_density(colour = "red") +
  geom_density(data = simlogls, aes(x = logl_ratio, fill = true_relat), alpha = 0.5)
```
OK, that is nice to see.  It is a little hard to make out---the red line above is the
observed distribution from all the pairs.  You see that it lands almost perfectly on
top of the simulated distribution for unrelated pairs.  That is good! It looks super clean.  


However, there are some troubling things here.  With a Logl Cutoff of 10 we should
expect almost no false positives, and yet R031681 is in three different pairs at that
level.  That is the only one that seems to have multiple parents, but it is a little
bit disquieting.  Here are this individual's genotypes:
```{r weird-fish}
 kelp_idx_frame %>% 
  filter(NMFS_DNA_ID == "R031681")
```
And here we can look at all its info:
```{r all-weird}
kelp_genos %>% 
  filter(NMFS_DNA_ID == "R031681") 
```
It has good read depths, but terrible allele balances at most loci.  That is super fishy.

What if we look at one of the other fish in there?
```{r another-one}
kelp_genos %>% 
  filter(NMFS_DNA_ID == "R015337") 
```
Those allele balances all tend to be larger than 0.7

### Contamination at R031681?

OK! My guess is that R031681 is a mixture of DNA from a two or more fish.  Since we are just taking the top two highest read-depth
haplotypes from each individual, at present, we wouldn't notice that this individual had super high read depths.  But,
we can easily go figure that out by grabbing this guys complete raw data and having a look at it.  
```{r check-contam, rows.print=20}
readRDS("../extdata/haplot-rds/gtseq50_96loci.rds") %>%
  tbl_df() %>%
  filter(id == "s13413") %>%
  arrange(locus, desc(depth))
```
Let's compare that to another individual, our friend R015337 from above:
```{r check-contam2, rows.print=20}
readRDS("../extdata/haplot-rds/gtseq33_96loci.rds") %>%
  tbl_df() %>%
  filter(id == "s7267") %>%
  arrange(locus, desc(depth))
```
Wow! Take a look at Plate_2_G06_Sat_EW987118_consensus (tab 3) between those fish, or tag_id_1184.  

Another thing to look at would be to check out the individual heterozygosities of all these fish.

### Looking at internal heterozygosities

If that guy is noticeably contaminated, we should see it in elevated internal heterozygosities.
We can do that like this:
```{r compute-int-hzs}
int_hz <- kg2 %>% 
  group_by(NMFS_DNA_ID, Locus) %>% 
  summarise(hz = Allele[1]!=Allele[2]) %>% 
  filter(!is.na(hz)) %>% 
  group_by(NMFS_DNA_ID) %>% 
  summarise(num_loc = n(), num_hz = sum(hz), fract_hz = num_hz / num_loc)
```
And now let us plot that and also put all the individuals (parents and offpring) that look likely
above on it.
```{r plot-int-hz}

```

##  Another tack---look at the few possible trios

This is just left here from other stuff. I can cannibalize some of the code for looking at that weird fish.



Another way to get at the issue that I think selection on some loci may be screwing
up the relationship inference is to look at the handful of individuals that had 
two inferred parents and check the trios for compatibility.  If they are spuriously-inferred
parents it should be pretty easy to identify incompatiblities.  But if they are correct, then
there should be no incompatibilities.  In the process, I will want to carry around the CKMR 
integer index of the allele (easier to look at and compare across generations) and I would also
like to have the allele frequencies (though I could add those on later.)
```{r inspect-trios}
two_pars <- result %>% 
  filter(value > 10) %>% 
  group_by(offspring, id1) %>% 
  filter(n() == 2) %>%
  arrange(offspring)

kid_ma_pa <- two_pars %>%
  group_by(offspring) %>%
  summarise(trio = paste(id1[1], id2[1], id2[2], sep = "-", collapse = "-"),
            kid = id1[1], ma = id2[1], pa = id2[2])

# now we join the genotypes on there for kid, "pa", and "ma"
trios_alleles <- kid_ma_pa %>%
  left_join(., kelp_genos %>% select(NMFS_DNA_ID, locus, gene_copy, allele) %>% rename(kid_allele = allele), by = c("kid" = "NMFS_DNA_ID")) %>%
  left_join(., kelp_genos %>% select(NMFS_DNA_ID, locus, gene_copy, allele) %>% rename(ma_allele = allele), by = c("ma" = "NMFS_DNA_ID", "locus", "gene_copy")) %>% 
  left_join(., kelp_genos %>% select(NMFS_DNA_ID, locus, gene_copy, allele) %>% rename(pa_allele = allele), by = c("pa" = "NMFS_DNA_ID", "locus", "gene_copy"))

# put the allele indexes on there to make it easier to read
kg_alles <- kg_ckmr_markers %>%
  select(Locus, Allele, AlleIdx) %>%
  rename(locus = Locus, allele = Allele, alle_idx = AlleIdx)

trios_idx <- trios_alleles %>%
  left_join(kg_alles %>% rename(kid_allele = allele, kid_alle_idx = alle_idx)) %>%
  left_join(kg_alles %>% rename(ma_allele = allele, ma_alle_idx = alle_idx)) %>%
  left_join(kg_alles %>% rename(pa_allele = allele, pa_alle_idx = alle_idx))

# now we can look for incompatibilities
compats <- trios_idx %>%
  group_by(trio, locus) %>%
  mutate(compat = (kid_allele[1] == kid_allele[2] & (kid_allele[1] %in% ma_allele & kid_allele[1] %in% pa_allele)) | 
           ( (kid_allele[1] != kid_allele[2]) & (
                 (kid_allele[1] %in% ma_allele & kid_allele[2] %in% pa_allele) | 
                                                 (kid_allele[2] %in% ma_allele & kid_allele[1] %in% pa_allele) ) ))

compats
```

That is worth looking at, but we can also summarize it by counting up the number of trio-incompatibilities for each of those offspring:
```{r count-trio-incompats}
compats %>%
  group_by(offspring) %>%
  summarise(num_incompat_loci = sum(compat == FALSE, na.rm = TRUE) / 2,
            num_non_missing_loci = sum(!is.na(compat)) / 2)
```

So that pretty much settles it---the actual false positive rate here is clearly higher than what we think it should be.  So, now we have to figure out
why that is.  Could be subdivision in the sample (either real or from a laboratory error?) Hmmm...

The other thing that is obviously worrisome is the shape of the Logl Distribution above (the black line)
for all the pairs.  It is almost bimodal, with some values much lower than what we get from simulation and 
also another peak which is higher than we get from simulation.  Almost as if there is some
unexpected structure in the data.  

So, the obvious thing to do would be a PCA with all the adults and all the juvies.


